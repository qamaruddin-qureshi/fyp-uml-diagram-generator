# Auto-generated test data subset from Architecture Dev Split
# This file is generated by scripts/extract_test_data.py
# Do not edit manually if you want to stay in sync with the split.

COMPONENT_TEST_DATA = [
    {
        'id': 1,
        'narration': "client UI communicates with the api service. The api service accesses a central database and uses key-value cache. The api service runs in a Docker container on a Dedicated host. Users access the system via mobile devices. The api service exposes GraphQL endpoint.",
    },
    {
        'id': 2,
        'narration': "frontend communicates with the auth service. The auth service accesses a central database and uses key-value cache. The auth service runs in a Docker container on a Cloud VM. Users access the system via mobile devices. The auth service exposes GraphQL endpoint.",
    },
    {
        'id': 3,
        'narration': "mobile frontend communicates with the auth service. The auth service accesses a MongoDB database and uses Redis cache. The auth service runs in a Docker container on a Dedicated host. Users access the system via mobile devices. The auth service exposes GraphQL endpoint.",
    },
    {
        'id': 4,
        'narration': "The Tracking UI sends requests to a Fleet Service. The Fleet Service stores data in a PostgreSQL database and uses a RabbitMQ broker. The Fleet Service is deployed inside an Amazon ECS cluster running on an AWS EC2 instance. The system integrates with an external Geotab telematics API. Users access the system through mobile tablets.",
    },
    {
        'id': 5,
        'narration': "web UI communicates with the backend service. The backend service accesses a MySQL database and uses key-value cache. The backend service runs in a container on a Cloud VM. Users access the system via web browsers. The backend service exposes HTTP API.",
    },
    {
        'id': 6,
        'narration': "mobile frontend communicates with the backend service. The backend service accesses a NoSQL database and uses Redis cache. The backend service runs in a container on a Linux server. Users access the system via desktop clients. The backend service exposes HTTP API.",
    },
    {
        'id': 7,
        'narration': "application frontend communicates with the auth service. The auth service accesses a relational database and uses Redis cache. The auth service runs in a container on a Ubuntu server. Users access the system via desktop clients. The auth service exposes REST endpoints.",
    },
    {
        'id': 8,
        'narration': "web UI communicates with the backend service. The backend service accesses a PostgreSQL database and uses Redis cache. The system integrates with External payment gateway.",
    },
    {
        'id': 9,
        'narration': "frontend communicates with the api service. The api service accesses a MySQL database and uses Redis cache. The api service runs in a container on a Debian server. Users access the system via desktop clients. The api service exposes GraphQL endpoint.",
    },
    {
        'id': 10,
        'narration': "client UI communicates with the course management service. The course management service accesses a NoSQL database and uses Redis cache. The system integrates with External payment gateway.",
    },
    {
        'id': 11,
        'narration': "mobile frontend communicates with the api service. The api service accesses a MySQL database and uses key-value cache. The system integrates with External payment gateway.",
    },
    {
        'id': 12,
        'narration': "web UI communicates with the payment service. The payment service accesses a central database and uses in-memory cache. The payment service runs in a Docker container on a Linux server. Users access the system via mobile devices. The payment service exposes HTTP API.",
    },
    {
        'id': 13,
        'narration': "client UI communicates with the payment service. The payment service accesses a central database and uses in-memory cache. The payment service runs in a Docker container on a Cloud VM. Users access the system via mobile devices. The payment service exposes HTTP API.",
    },
    {
        'id': 14,
        'narration': "A decentralized finance dashboard uses the Zapper API to aggregate protocol positions. The dashboard uses Amazon Simple Storage Service (S3) for caching user configuration. The Dashboard interacts with the Ethereum mainnet via a QuickNode endpoint. The frontend is written in TypeScript. Users connect their wallets using a Ledger hardware device.",
    },
    {
        'id': 15,
        'narration': "web UI communicates with the api service. The api service accesses a MongoDB database and uses in-memory cache. The api service runs in a container on a Ubuntu server. Users access the system via mobile devices. The api service exposes HTTP API.",
    },
    {
        'id': 16,
        'narration': "frontend communicates with the messaging service. The messaging service accesses a MySQL database and uses Redis cache. The messaging service runs in a Docker container on a Cloud VM. Users access the system via web browsers. The messaging service exposes GraphQL endpoint.",
    },
    {
        'id': 17,
        'narration': "client UI communicates with the messaging service. The messaging service accesses a MongoDB database and uses in-memory cache. The system integrates with PayPal.",
    },
    {
        'id': 18,
        'narration': "application frontend communicates with the messaging service. The messaging service accesses a NoSQL database and uses Redis cache. The system integrates with PayPal.",
    },
    {
        'id': 19,
        'narration': "The Claims Portal interacts with the OCR Engine. Engine uses an S3 File Store. Portal runs on an IIS Server. Clerks use Desktops.",
    },
    {
        'id': 20,
        'narration': "client UI communicates with the backend service. The backend service accesses a MongoDB database and uses key-value cache. The system integrates with Stripe.",
    },
    {
        'id': 21,
        'narration': "client UI communicates with the course management service. The course management service accesses a central database and uses Redis cache. The course management service runs in a container on a Ubuntu server. Users access the system via web browsers. The course management service exposes GraphQL endpoint.",
    },
    {
        'id': 22,
        'narration': "application frontend communicates with the api service. The api service accesses a MongoDB database and uses key-value cache. The api service runs in a Docker container on a Debian server. Users access the system via web browsers. The api service exposes HTTP API.",
    },
    {
        'id': 23,
        'narration': "application frontend communicates with the payment service. The payment service accesses a MongoDB database and uses key-value cache. The payment service runs in a container on a Dedicated host. Users access the system via desktop clients. The payment service exposes REST endpoints.",
    },
    {
        'id': 24,
        'narration': "client UI communicates with the auth service. The auth service accesses a MongoDB database and uses Redis cache. The auth service runs in a Docker container on a Linux server. Users access the system via mobile devices. The auth service exposes REST endpoints.",
    },
    {
        'id': 25,
        'narration': "application frontend communicates with the payment service. The payment service accesses a NoSQL database and uses Redis cache. The payment service runs in a container on a Dedicated host. Users access the system via web browsers. The payment service exposes REST endpoints.",
    },
    {
        'id': 26,
        'narration': "application frontend communicates with the order service. The order service accesses a central database and uses in-memory cache. The order service runs in a container on a Cloud VM. Users access the system via web browsers. The order service exposes GraphQL endpoint.",
    },
    {
        'id': 27,
        'narration': "The system is deployed on Linux server instances running Docker container environments. Artifacts are packaged as container images. Clients connect via mobile devices.",
    },
    {
        'id': 28,
        'narration': "client UI communicates with the backend service. The backend service accesses a relational database and uses Redis cache. The backend service runs in a Docker container on a Linux server. Users access the system via desktop clients. The backend service exposes GraphQL endpoint.",
    },
    {
        'id': 29,
        'narration': "application frontend communicates with the payment service. The payment service accesses a central database and uses key-value cache. The payment service runs in a Docker container on a Debian server. Users access the system via web browsers. The payment service exposes REST endpoints.",
    },
    {
        'id': 30,
        'narration': "client UI communicates with the messaging service. The messaging service accesses a NoSQL database and uses Redis cache. The messaging service runs in a Docker container on a Dedicated host. Users access the system via desktop clients. The messaging service exposes HTTP API.",
    },
    {
        'id': 31,
        'narration': "The User Service exposes a REST API. The Application Frontend requires the REST API. The User Service implements the Authentication Interface. The Billing Service consumes the Authentication Interface.",
    },
    {
        'id': 32,
        'narration': "The E-Commerce System contains the Inventory Module and the Order Module. The Inventory Module contains the Stock Service. The Order Module is part of the Sales Layer. The Sales Layer contains the Cart Service.",
    },
    {
        'id': 33,
        'narration': "The Web Server connects to the App Server via port 8080. The App Server defines port 9090 for admin access. The Database listens at port 5432.",
    },
    {
        'id': 34,
        'narration': "The Order Service publishes messages to the Events Topic. The Events Topic is managed by the Kafka Broker. The Inventory Service consumes messages from the Events Topic via a Consumer Group.",
    },
    {
        'id': 35,
        'narration': "The Data Pipeline consists of an Ingestion Service, a Transformation Job, and a Loader. The Ingestion Service sends data to the Transformation Job via a Staging Bucket. The Transformation Job writes to the Data Warehouse.",
    },
    {
        'id': 36,
        'narration': "The Wallet App interacts with the Smart Contract via the RPC Provider. The Smart Contract runs on the Ethereum Blockchain. The RPC Provider connects to the Blockchain Node.",
    },
]

DEPLOYMENT_TEST_DATA = [
    {
        'id': 1,
        'narration': "client UI communicates with the api service. The api service accesses a central database and uses key-value cache. The api service runs in a Docker container on a Dedicated host. Users access the system via mobile devices. The api service exposes GraphQL endpoint.",
    },
    {
        'id': 2,
        'narration': "frontend communicates with the auth service. The auth service accesses a central database and uses key-value cache. The auth service runs in a Docker container on a Cloud VM. Users access the system via mobile devices. The auth service exposes GraphQL endpoint.",
    },
    {
        'id': 3,
        'narration': "mobile frontend communicates with the auth service. The auth service accesses a MongoDB database and uses Redis cache. The auth service runs in a Docker container on a Dedicated host. Users access the system via mobile devices. The auth service exposes GraphQL endpoint.",
    },
    {
        'id': 4,
        'narration': "The Tracking UI sends requests to a Fleet Service. The Fleet Service stores data in a PostgreSQL database and uses a RabbitMQ broker. The Fleet Service is deployed inside an Amazon ECS cluster running on an AWS EC2 instance. The system integrates with an external Geotab telematics API. Users access the system through mobile tablets.",
    },
    {
        'id': 5,
        'narration': "web UI communicates with the backend service. The backend service accesses a MySQL database and uses key-value cache. The backend service runs in a container on a Cloud VM. Users access the system via web browsers. The backend service exposes HTTP API.",
    },
    {
        'id': 6,
        'narration': "mobile frontend communicates with the backend service. The backend service accesses a NoSQL database and uses Redis cache. The backend service runs in a container on a Linux server. Users access the system via desktop clients. The backend service exposes HTTP API.",
    },
    {
        'id': 7,
        'narration': "application frontend communicates with the auth service. The auth service accesses a relational database and uses Redis cache. The auth service runs in a container on a Ubuntu server. Users access the system via desktop clients. The auth service exposes REST endpoints.",
    },
    {
        'id': 8,
        'narration': "web UI communicates with the backend service. The backend service accesses a PostgreSQL database and uses Redis cache. The system integrates with External payment gateway.",
    },
    {
        'id': 9,
        'narration': "frontend communicates with the api service. The api service accesses a MySQL database and uses Redis cache. The api service runs in a container on a Debian server. Users access the system via desktop clients. The api service exposes GraphQL endpoint.",
    },
    {
        'id': 10,
        'narration': "client UI communicates with the course management service. The course management service accesses a NoSQL database and uses Redis cache. The system integrates with External payment gateway.",
    },
    {
        'id': 11,
        'narration': "mobile frontend communicates with the api service. The api service accesses a MySQL database and uses key-value cache. The system integrates with External payment gateway.",
    },
    {
        'id': 12,
        'narration': "web UI communicates with the payment service. The payment service accesses a central database and uses in-memory cache. The payment service runs in a Docker container on a Linux server. Users access the system via mobile devices. The payment service exposes HTTP API.",
    },
    {
        'id': 13,
        'narration': "client UI communicates with the payment service. The payment service accesses a central database and uses in-memory cache. The payment service runs in a Docker container on a Cloud VM. Users access the system via mobile devices. The payment service exposes HTTP API.",
    },
    {
        'id': 14,
        'narration': "A decentralized finance dashboard uses the Zapper API to aggregate protocol positions. The dashboard uses Amazon Simple Storage Service (S3) for caching user configuration. The Dashboard interacts with the Ethereum mainnet via a QuickNode endpoint. The frontend is written in TypeScript. Users connect their wallets using a Ledger hardware device.",
    },
    {
        'id': 15,
        'narration': "web UI communicates with the api service. The api service accesses a MongoDB database and uses in-memory cache. The api service runs in a container on a Ubuntu server. Users access the system via mobile devices. The api service exposes HTTP API.",
    },
    {
        'id': 16,
        'narration': "frontend communicates with the messaging service. The messaging service accesses a MySQL database and uses Redis cache. The messaging service runs in a Docker container on a Cloud VM. Users access the system via web browsers. The messaging service exposes GraphQL endpoint.",
    },
    {
        'id': 17,
        'narration': "client UI communicates with the messaging service. The messaging service accesses a MongoDB database and uses in-memory cache. The system integrates with PayPal.",
    },
    {
        'id': 18,
        'narration': "application frontend communicates with the messaging service. The messaging service accesses a NoSQL database and uses Redis cache. The system integrates with PayPal.",
    },
    {
        'id': 19,
        'narration': "The Claims Portal interacts with the OCR Engine. Engine uses an S3 File Store. Portal runs on an IIS Server. Clerks use Desktops.",
    },
    {
        'id': 20,
        'narration': "client UI communicates with the backend service. The backend service accesses a MongoDB database and uses key-value cache. The system integrates with Stripe.",
    },
    {
        'id': 21,
        'narration': "client UI communicates with the course management service. The course management service accesses a central database and uses Redis cache. The course management service runs in a container on a Ubuntu server. Users access the system via web browsers. The course management service exposes GraphQL endpoint.",
    },
    {
        'id': 22,
        'narration': "application frontend communicates with the api service. The api service accesses a MongoDB database and uses key-value cache. The api service runs in a Docker container on a Debian server. Users access the system via web browsers. The api service exposes HTTP API.",
    },
    {
        'id': 23,
        'narration': "application frontend communicates with the payment service. The payment service accesses a MongoDB database and uses key-value cache. The payment service runs in a container on a Dedicated host. Users access the system via desktop clients. The payment service exposes REST endpoints.",
    },
    {
        'id': 24,
        'narration': "client UI communicates with the auth service. The auth service accesses a MongoDB database and uses Redis cache. The auth service runs in a Docker container on a Linux server. Users access the system via mobile devices. The auth service exposes REST endpoints.",
    },
    {
        'id': 25,
        'narration': "application frontend communicates with the payment service. The payment service accesses a NoSQL database and uses Redis cache. The payment service runs in a container on a Dedicated host. Users access the system via web browsers. The payment service exposes REST endpoints.",
    },
    {
        'id': 26,
        'narration': "application frontend communicates with the order service. The order service accesses a central database and uses in-memory cache. The order service runs in a container on a Cloud VM. Users access the system via web browsers. The order service exposes GraphQL endpoint.",
    },
    {
        'id': 27,
        'narration': "The system is deployed on Linux server instances running Docker container environments. Artifacts are packaged as container images. Clients connect via mobile devices.",
    },
    {
        'id': 28,
        'narration': "client UI communicates with the backend service. The backend service accesses a relational database and uses Redis cache. The backend service runs in a Docker container on a Linux server. Users access the system via desktop clients. The backend service exposes GraphQL endpoint.",
    },
    {
        'id': 29,
        'narration': "application frontend communicates with the payment service. The payment service accesses a central database and uses key-value cache. The payment service runs in a Docker container on a Debian server. Users access the system via web browsers. The payment service exposes REST endpoints.",
    },
    {
        'id': 30,
        'narration': "client UI communicates with the messaging service. The messaging service accesses a NoSQL database and uses Redis cache. The messaging service runs in a Docker container on a Dedicated host. Users access the system via desktop clients. The messaging service exposes HTTP API.",
    },
]
